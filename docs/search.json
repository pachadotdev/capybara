[
  {
    "title": "apes",
    "url": "reference/apes.html",
    "content": "apes Compute average partial effects after fitting binary choice models with a 1,2,3-way error component apes( object = NULL, n_pop = NULL, panel_structure = c(\"classic\", \"network\"), sampling_fe = c(\"independence\", \"unrestricted\"), weak_exo = FALSE ) objectan object of class \"bias_corr\" or \"feglm\"; currently restricted to statsbinomial. n_pop unsigned integer indicating a finite population correction for the estimation of the covariance matrix of the average partial effects proposed by Cruz-Gonzalez, Fernández-Val, and Weidner (2017). The correction factor is computed as follows: (n^ - n) / (n^ - 1)(n_pop - n) / (n_pop - 1), where n^n_pop and nn are the sizes of the entire population and the full sample size. Default is NULL, which refers to a factor of zero and a covariance obtained by the delta method. panel_structure a string equal to \"classic\" or \"network\" which determines the structure of the panel used. \"classic\" denotes panel structures where for example the same cross-sectional units are observed several times (this includes pseudo panels). \"network\" denotes panel structures where for example bilateral trade flows are observed for several time periods. Default is \"classic\". sampling_fe a string equal to \"independence\" or \"unrestricted\" which imposes sampling assumptions about the unobserved effects. \"independence\" imposes that all unobserved effects are independent sequences. \"unrestricted\" does not impose any sampling assumptions. Note that this option only affects the optional finite population correction. Default is \"independence\". weak_exo logical indicating if some of the regressors are assumed to be weakly exogenous (e.g. predetermined). If object is of class \"bias_corr\", the option will be automatically set to TRUE if the chosen bandwidth parameter is larger than zero. Note that this option only affects the estimation of the covariance matrix. Default is FALSE, which assumes that all regressors are strictly exogenous. The function \"apes\". \">apes returns a named list of class \"apes\".  apes is a post-estimation routine that can be used to estimate average partial effects with respect to all covariates in the model and the corresponding covariance matrix. The estimation of the covariance is based on a linear approximation (delta method) plus an optional finite population correction. Note that the command automatically determines which of the regressors are binary or non-binary. Remark: The routine currently does not allow to compute average partial effects based on functional forms like interactions and polynomials. mtcars2  mean(mtcars2$mpg), 1L, 0L) # Fit 'feglm()' mod bias_corr and feglm",
    "type": "function"
  },
  {
    "title": "bias_corr",
    "url": "reference/bias_corr.html",
    "content": "bias_corr Asymptotic bias correction after fitting binary choice models with a 1,2,3-way error component bias_corr(object = NULL, l = 0L, panel_structure = c(\"classic\", \"network\")) objectan object of class \"feglm\". l integer indicating a bandwidth for the estimation of spectral densities proposed by Hahn and Kuersteiner (2011). The default is zero, which should be used if all regressors are assumed to be strictly exogenous with respect to the idiosyncratic error term. In the presence of weakly exogenous regressors, e.g. lagged outcome variables, we suggest to choose a bandwidth between one and four. Note that the order of factors to be partialed out is important for bandwidths larger than zero. panel_structure a string equal to \"classic\" or \"network\" which determines the structure of the panel used. \"classic\" denotes panel structures where for example the same cross-sectional units are observed several times (this includes pseudo panels). \"network\" denotes panel structures where for example bilateral trade flows are observed for several time periods. Default is \"classic\". A named list of classes \"bias_corr\" and \"feglm\". Post-estimation routine to substantially reduce the incidental parameter bias problem. Applies the analytical bias correction derived by Fernández-Val and Weidner (2016) and Hinz, Stammann, and Wanner (2020) to obtain bias-corrected estimates of the structural parameters and is currently restricted to statsbinomial with 1,2,3-way fixed effects. mtcars2  mean(mtcars2$mpg), 1L, 0L) # Fit 'feglm()' mod feglm",
    "type": "function"
  },
  {
    "title": "feglm",
    "url": "reference/feglm.html",
    "content": "feglm GLM fitting with high-dimensional k-way fixed effects feglm( formula = NULL, data = NULL, family = gaussian(), weights = NULL, beta_start = NULL, eta_start = NULL, offset = NULL, control = NULL ) formulaan object of class \"formula\": a symbolic description of the model to be fitted. formula must be of type response ~ slopes | fixed_effects | cluster. data an object of class \"data.frame\" containing the variables in the model. The expected input is a dataset with the variables specified in formula and a number of rows at least equal to the number of variables in the model. family the link function to be used in the model. Similar to statsglm.fit this has to be the result of a call to a family function. Default is gaussian(). See statsfamily for details of family functions. weights an optional string with the name of the prior weights variable in data. beta_start an optional vector of starting values for the structural parameters in the linear predictor. Default is = 0 = 0. eta_start an optional vector of starting values for the linear predictor. offset an optional formula or numeric vector specifying an a priori known component to be included in the linear predictor. If a formula, it should be of the form ~ log(variable). control a named list of parameters for controlling the fitting process. See fit_control for details. A named list of class \"feglm\". The list contains the following fifteen elements: coefficients a named vector of the estimated coefficients eta a vector of the linear predictor weights a vector of the weights used in the estimation hessian a matrix with the numerical second derivatives deviance the deviance of the model null_deviance the null deviance of the model conv a logical indicating whether the model converged iter the number of iterations needed to converge nobs a named vector with the number of observations used in the estimation indicating the dropped and perfectly predicted observations fe_levels a named vector with the number of levels in each fixed effects nms_fe a list with the names of the fixed effects variables formula the formula used in the model data the data used in the model after dropping non-contributing observations family the family used in the model control the control list used in the model  feglm can be used to fit generalized linear models with many high-dimensional fixed effects. The term fixed effect means having one intercept for each level in each category.  If feglm does not converge this is often a sign of linear dependence between one or more regressors and a fixed effects category. In this case, you should carefully inspect your model specification.  # Model without clustering - uses inverse Hessian for vcov mod <- feglm(mpg ~ wt | cyl, mtcars, family = poisson(link = \"log\")) summary(mod) # Model with clustering - uses sandwich vcov automatically mod <- feglm(mpg ~ wt | cyl | am, mtcars, family = poisson(link = \"log\")) summary(mod) Gaure, S. (2013). \"OLS with Multiple High Dimensional Category Variables\". Computational Statistics and Data Analysis, 66. Marschner, I. (2011). \"glm2: Fitting generalized linear models with convergence problems\". The R Journal, 3(2). Stammann, A., F. Heiss, and D. McFadden (2016). \"Estimating Fixed Effects Logit Models with Large Panel Data\". Working paper. Stammann, A. (2018). \"Fast and Feasible Estimation of Generalized Linear Models with High-Dimensional k-Way Fixed Effects\". ArXiv e-prints.",
    "type": "function"
  },
  {
    "title": "felm",
    "url": "reference/felm.html",
    "content": "felm LM fitting with high-dimensional k-way fixed effects felm(formula = NULL, data = NULL, weights = NULL, control = NULL) formulaan object of class \"formula\": a symbolic description of the model to be fitted. formula must be of type response ~ slopes | fixed_effects | cluster. data an object of class \"data.frame\" containing the variables in the model. The expected input is a dataset with the variables specified in formula and a number of rows at least equal to the number of variables in the model. weights an optional string with the name of the prior weights variable in data. control a named list of parameters for controlling the fitting process. See fit_control for details. A named list of class \"felm\". The list contains the following eleven elements: coefficients a named vector of the estimated coefficients fitted_values a vector of the estimated dependent variable weights a vector of the weights used in the estimation hessian a matrix with the numerical second derivatives null_deviance the null deviance of the model nobs a named vector with the number of observations used in the estimation indicating the dropped and perfectly predicted observations fe_levels a named vector with the number of levels in each fixed effect nms_fe a list with the names of the fixed effects variables formula the formula used in the model data the data used in the model after dropping non-contributing observations control the control list used in the model  feglm can be used to fit linear models with many high-dimensional fixed effects. The estimation procedure is based on unconditional maximum likelihood and can be interpreted as a weighted demeaning approach. # Model with fixed effects mod <- felm(log(mpg) ~ log(wt) | cyl, mtcars) summary(mod) # Model without fixed effects but with clustered standard errors # Note: Use 0 to indicate no fixed effects when specifying clusters mod <- felm(log(mpg) ~ log(wt) | 0 | cyl, mtcars) summary(mod) Gaure, S. (2013). \"OLS with Multiple High Dimensional Category Variables\". Computational Statistics and Data Analysis, 66. Marschner, I. (2011). \"glm2: Fitting generalized linear models with convergence problems\". The R Journal, 3(2). Stammann, A., F. Heiss, and D. McFadden (2016). \"Estimating Fixed Effects Logit Models with Large Panel Data\". Working paper. Stammann, A. (2018). \"Fast and Feasible Estimation of Generalized Linear Models with High-Dimensional k-Way Fixed Effects\". ArXiv e-prints.",
    "type": "function"
  },
  {
    "title": "fenegbin",
    "url": "reference/fenegbin.html",
    "content": "fenegbin Negative Binomial model fitting with high-dimensional k-way fixed effects fenegbin( formula = NULL, data = NULL, weights = NULL, beta_start = NULL, eta_start = NULL, init_theta = NULL, link = c(\"log\", \"identity\", \"sqrt\"), offset = NULL, control = NULL ) formulaan object of class \"formula\": a symbolic description of the model to be fitted. formula must be of type response ~ slopes | fixed_effects | cluster. data an object of class \"data.frame\" containing the variables in the model. The expected input is a dataset with the variables specified in formula and a number of rows at least equal to the number of variables in the model. weights an optional string with the name of the prior weights variable in data. beta_start an optional vector of starting values for the structural parameters in the linear predictor. Default is = 0 = 0. eta_start an optional vector of starting values for the linear predictor. init_theta an optional initial value for the theta parameter (see MASSglm.nb). link the link function. Must be one of \"log\", \"sqrt\", or \"identity\". offset an optional formula or numeric vector specifying an a priori known component to be included in the linear predictor. If a formula, it should be of the form ~ log(variable). control a named list of parameters for controlling the fitting process. See fit_control for details. A named list of class \"feglm\". The list contains the following eighteen elements: coefficients a named vector of the estimated coefficients eta a vector of the linear predictor weights a vector of the weights used in the estimation hessian a matrix with the numerical second derivatives deviance the deviance of the model null_deviance the null deviance of the model conv a logical indicating whether the model converged iter the number of iterations needed to converge theta the estimated theta parameter iter_outer the number of outer iterations conv_outer a logical indicating whether the outer loop converged nobs a named vector with the number of observations used in the estimation indicating the dropped and perfectly predicted observations fe_levels a named vector with the number of levels in each fixed effects nms_fe a list with the names of the fixed effects variables formula the formula used in the model data the data used in the model after dropping non-contributing observations family the family used in the model control the control list used in the model  A routine that uses the same internals as feglm.  # check the feglm examples for the details about clustered standard errors mod <- fenegbin(mpg ~ wt | cyl, mtcars) summary(mod)",
    "type": "function"
  },
  {
    "title": "fepoisson",
    "url": "reference/fepoisson.html",
    "content": "fepoisson Poisson model fitting high-dimensional with k-way fixed effects fepoisson( formula = NULL, data = NULL, weights = NULL, beta_start = NULL, eta_start = NULL, offset = NULL, control = NULL ) formulaan object of class \"formula\": a symbolic description of the model to be fitted. formula must be of type response ~ slopes | fixed_effects | cluster. data an object of class \"data.frame\" containing the variables in the model. The expected input is a dataset with the variables specified in formula and a number of rows at least equal to the number of variables in the model. weights an optional string with the name of the prior weights variable in data. beta_start an optional vector of starting values for the structural parameters in the linear predictor. Default is = 0 = 0. eta_start an optional vector of starting values for the linear predictor. offset an optional formula or numeric vector specifying an a priori known component to be included in the linear predictor. If a formula, it should be of the form ~ log(variable). control a named list of parameters for controlling the fitting process. See fit_control for details. A named list of class \"feglm\".  A wrapper for family = poisson(). \">feglm with family = poisson().  # check the feglm examples for the details about clustered standard errors mod <- fepoisson(mpg ~ wt | cyl, mtcars) summary(mod)",
    "type": "function"
  },
  {
    "title": "fit_control",
    "url": "reference/fit_control.html",
    "content": "fit_control Set feglm Control Parameters fit_control( dev_tol = 1e-08, center_tol = 1e-06, center_tol_loose = 1e-04, collin_tol = 1e-10, step_halving_factor = 0.5, alpha_tol = 1e-08, iter_max = 25L, iter_center_max = 10000L, iter_inner_max = 50L, iter_alpha_max = 10000L, step_halving_memory = 0.9, max_step_halving = 2L, start_inner_tol = 1e-06, grand_acc_period = 4L, centering = \"berge\", sep_tol = 1e-08, sep_zero_tol = 1e-12, sep_max_iter = 200L, sep_simplex_max_iter = 2000L, sep_use_relu = TRUE, sep_use_simplex = TRUE, return_fe = TRUE, keep_tx = FALSE, check_separation = TRUE, init_theta = 0, vcov_type = NULL ) dev_toltolerance level for the first stopping condition of the maximization routine. The stopping condition is based on the relative change of the deviance in iteration r and can be expressed as follows: |dev_r - dev_r - 1| / (0.1 + |dev_r|) 1.0e-08. center_tol tolerance level for the stopping condition of the centering algorithm. The stopping condition is based on the relative change of the centered variable similar to the 'lfe' package. The default is 1.0e-06. center_tol_loose initial (loose) tolerance for adaptive centering in GLM iterations. During early IRLS iterations when deviance is changing rapidly, this looser tolerance is used to save computation. As the GLM converges, the tolerance is tightened towards center_tol. The default is 1.0e-04. collin_tol tolerance level for detecting collinearity. The default is 1.0e-07. step_halving_factor numeric indicating the factor by which the step size is halved to iterate towards convergence. This is used to control the step size during optimization. The default is 0.5. alpha_tol tolerance for fixed effects (alpha) convergence. The default is 1.0e-06. iter_max integer indicating the maximum number of iterations in the maximization routine. The default is 25L. iter_center_max integer indicating the maximum number of iterations in the centering algorithm. The default is 10000L. iter_inner_max integer indicating the maximum number of iterations in the inner loop of the centering algorithm. The default is 50L. iter_alpha_max maximum iterations for fixed effects computation. The default is 10000L. step_halving_memory numeric memory factor for step-halving algorithm. Controls how much of the previous iteration is retained. The default is 0.9. max_step_halving maximum number of post-convergence step-halving attempts. The default is 2. start_inner_tol starting tolerance for inner solver iterations. The default is 1.0e-04. grand_acc_period integer indicating the period (in iterations) for grand acceleration in the centering algorithm. Grand acceleration applies a second-level Irons-Tuck extrapolation on the overall convergence trajectory. Lower values (e.g., 4-10) may speed up convergence for difficult problems. Set to a very large value (e.g., 10000) to effectively disable. The default is 4L. centering character string indicating the centering algorithm to use for demeaning fixed effects. \"stammann\" (default) uses alternating projections with Gauss-Seidel sweeps plus Irons-Tuck and grand acceleration on coefficient vectors. Each iteration updates each fixed-effect dimension in sequence. \"berge\" uses a fixed-point reformulation as described in Berge (2018): all FE updates are composed into a single map F = f_T f_I, reducing the problem to finding ^* = F(^*). The Irons and Tuck (1969) acceleration is then applied to the composed iteration. Both methods use warm-starting and grand acceleration. sep_tol tolerance for separation detection. The default is 1.0e-08. sep_zero_tol tolerance for treating values as zero in separation detection. The default is 1.0e-12. sep_max_iter maximum iterations for ReLU separation detection algorithm. The default is 200L. sep_simplex_max_iter maximum iterations for simplex separation detection algorithm. The default is 2000L. sep_use_relu logical indicating whether to use the ReLU algorithm for separation detection. The default is TRUE. sep_use_simplex logical indicating whether to use the simplex algorithm for separation detection. The default is TRUE. return_fe logical indicating if the fixed effects should be returned. This can be useful when fitting general equilibrium models where skipping the fixed effects for intermediate steps speeds up computation. The default is TRUE and only applies to the feglm class. keep_tx logical indicating if the centered regressor matrix should be stored. The centered regressor matrix is required for some covariance estimators, bias corrections, and average partial effects. This option saves some computation time at the cost of memory. The default is TRUE. check_separation logical indicating whether to perform separation detection for Poisson models. When TRUE (default), observations with perfect prediction are automatically detected and excluded from estimation. Set to FALSE to skip this check and speed up computation when separation is known not to be an issue. The default is TRUE. init_theta Initial value for the negative binomial dispersion parameter (theta). The default is 0.0. vcov_type Optional character string specifying the type of variance-covariance estimator to be used. It only applies for formulas with a cluster variable like z ~ x + y | fe | cl. When NULL (default), the variance covariance matrix follows a regular sandwich estimator. When set to \"m-estimator\", uses standard clustered M-estimator sandwich. When set to \"m-estimator-dyadic\", uses dyadic clustering that accounts for correlation between observations sharing entities. For dyadic clustering, specify two entity columns in the formula like z ~ x + y | fe | cl1 + cl2. A named list of control parameters. Set and change parameters used for fitting feglm, felm, and fenegbin. Termination conditions are similar to statsglm. fit_control(0.05, 0.05, 10L, 10L, TRUE, TRUE, TRUE) feglm, felm, and fenegbin",
    "type": "function"
  },
  {
    "title": "summary_table",
    "url": "reference/summary_table.html",
    "content": "summary_table Generate formatted regression tables summary_table( ..., coef_digits = 3, se_digits = 3, stars = TRUE, latex = FALSE, model_names = NULL, caption = NULL, label = NULL ) ...One or more model objects of felm or feglm class. coef_digits Number of digits for coefficients. The default is 3. se_digits Number of digits for standard errors. The default is 3. stars Whether to include significance stars. The default is TRUE. latex Whether to output as LaTeX code. The default is FALSE. model_names Optional vector of custom model names caption Optional caption for the table (LaTeX only) label Optional label for cross-referencing (LaTeX only) A formatted table Generate formatted regression tables m1 <- felm(mpg ~ wt | cyl, mtcars) m2 <- fepoisson(mpg ~ wt | cyl, mtcars) summary_table(m1, m2, model_names = c(\"Linear\", \"Poisson\"))",
    "type": "function"
  },
  {
    "title": "Poisson Pseudo-Maximum Likelihood (PPML) Model with Cluster-Robust Standard Errors",
    "url": "vignettes/intro.html",
    "content": "knitr::opts_chunk$set( collapse = TRUE, comment = \"#>\" ) We will estimate a Poisson Pseudo-Maximum Likelihood (PPML) model using the data available in this package with the idea of replicating the PPML results from Table 3 in @yotov2016advanced. This requires to include exporter-time and importer-time fixed effects, and to cluster the standard errors by exporter-importer pairs. The PPML especification corresponds to: \\begin{align} X_{ij,t} =& \\:\\exp\\left[\\beta_1 \\log(DIST)_{i,j} + \\beta_2 CNTG_{i,j} +\\right.\\\\ \\text{ }& \\:\\left.\\beta_3 LANG_{i,j} + \\beta_4 CLNY_{i,j} + \\pi_{i,t} + \\chi_{i,t}\\right] \\times \\varepsilon_{ij,t}. \\end{align} We use dplyr to obtain the log of the distance. This model excludes domestic flows, therefore we need to subset the data also with dplyr. Required packages: ``r library(capybara) We can use the fepoisson() function to obtain the estimated coefficients and we add the fixed effects as | exp_year + imp_year in the formula. Model estimation: `r fit <- fepoisson( trade ~ log_dist + cntg + lang + clny + rta | exp_year + imp_year, data = trade_panel ) summary(fit) `r Formula: trade ~ log_dist + cntg + lang + clny + rta | exp_year + imp_year Family: Poisson Estimates: | | Estimate | Std. Error | z value | Pr(>|z|) | |----------|----------|------------|------------|------------| | log_dist | -0.8216 | 0.0004 | -2194.0448 | 0.0000 | | cntg | 0.4155 | 0.0009 | 476.0613 | 0.0000 | | lang | 0.2499 | 0.0008 | 296.8884 | 0.0000 | | clny | -0.2054 | 0.0010 | -206.3476 | 0.0000 | | rta | 0.1907 | 0.0010 | 191.0964 | 0.0000 | Significance codes: 99.9%; * 99%; 95%; . 90% Pseudo R-squared: 0.587 Number of observations: Full 28152; Missing 0; Perfect classification 0 Number of Fisher Scoring iterations: 11 The coefficients are almost identical to those in Table 3 from @yotov2016advanced that were obtained with Stata. The difference is attributed to the different fitting algorithms used by the software. Capybara uses the demeaning algorithm proposed by @stammann2018fast. `r fit <- fepoisson( trade ~ log_dist + cntg + lang + clny + rta | exp_year + imp_year | pair, data = trade_panel ) summary(fit, type = \"clustered\") ``r Formula: trade ~ log_dist + cntg + lang + clny + rta | exp_year + imp_year | pair Family: Poisson Estimates: | | Estimate | Std. Error | z value | Pr(>|z|) | |----------|----------|------------|---------|------------| | log_dist | -0.8216 | 0.1567 | -5.2437 | 0.0000 | | cntg | 0.4155 | 0.4568 | 0.9097 | 0.3630 | | lang | 0.2499 | 0.3997 | 0.6252 | 0.5319 | | clny | -0.2054 | 0.3287 | -0.6250 | 0.5320 | | rta | 0.1907 | 0.7657 | 0.2491 | 0.8033 | Significance codes: 99.9%; * 99%; 95%; . 90% Pseudo R-squared: 0.587 Number of observations: Full 28152; Missing 0; Perfect classification 0 Number of Fisher Scoring iterations: 11 The result is similar and the numerical difference comes fom the variance-covariance matrix estimation method. Capybara clustering algorithm is based on @cameron2011robust. References",
    "type": "vignette"
  },
  {
    "title": "Nonexistence of estimates of Poisson models",
    "url": "vignettes/separation.html",
    "content": "knitr::opts_chunk$set( collapse = TRUE, comment = \"#>\" ) This vignette is adapted from https://github.com/sergiocorreia/ppmlhdfe/blob/master/guides/nonexistence_benchmarks.md#r-packages. Example 1 library(capybara) The table below shows a dataset with 12 observations and four regressors. Observations 5 is separated because $y=0$ and $z \\neq x_2 - x_1$ is positive in those observations, and zero otherwise. ppmlhdfe$example1 which(ppmlhdfe$example1$x2 - ppmlhdfe$example1$x1 != 0 & ppmlhdfe$example1$y == 0) Base R shall not give a warning when estimating a Poisson model on this data. glm( y ~ x1 + x2 + x3 + x4, data = ppmlhdfe$example1, family = poisson() ) Capybara will detect separation on this dataset. fepoisson( y ~ x1 + x2 + x3 + x4, data = ppmlhdfe$example1 ) Example 2 The table below shows a different dataset with 12 observations and four regressors. Observations 2, 3, 6, 7 and 8 are separated because $y=0$ and $z > x_2 - x_1$ is positive in those observations, and zero otherwise. ppmlhdfe$example2 which(ppmlhdfe$example2$x2 - ppmlhdfe$example2$x1 > 0 & ppmlhdfe$example2$y == 0) Base R shall give a convergence warning when estimating a Poisson model on this data. glm( y ~ x1 + x2 + x3 + x4, data = ppmlhdfe$example2, family = poisson() ) Capybara will detect separation on this dataset. fepoisson( y ~ x1 + x2 + x3 + x4, data = ppmlhdfe$example2 ) Example 3 (fixed effects) Base R shall not give a warning when estimating a Poisson model with fixed effects on the dataset below. The separation in this case is less clear, which motivates why capybara uses linear programming to detect separation in Poisson models. ppmlhdfe$fe1 Base R shall not give a warning when estimating a Poisson model with fixed effects on this data. glm( y ~ x1 + x2 + factor(i) + factor(j), data = ppmlhdfe$fe1, family = poisson() ) Capybara will detect separation when estimating Poisson models. fepoisson( y ~ x1 + x2 | i + j, data = ppmlhdfe$fe1 ) 'ppmlhdfe' will also detect separation when estimating Poisson models with fixed effects. ``stata . ppmlhdfe y x1 x2, a(i j) (simplex method dropped 4 separated observations) (dropped 1 singleton observations) note: 1 variable omitted because of collinearity: x2 $$ Stopping (no negative residuals); separation found in 0 observations (1 iterations and 732 subiterations) Iteration 1: deviance = 1.4149e+01 eps = . iters = 4 tol = 1.0e-04 ... Iteration 6: deviance = 1.3364e+01 eps = 1.85e-16 iters = 3 tol = 1.0e-07 ------------------------------------------------------------------------------- (legend: p: exact partial-out s: exact solver h: step-halving o: epsilon > below tolerance) Converged in 6 iterations and 21 HDFE sub-iterations (tol = 1.0e-08) HDFE PPML regression No. of obs = 13 Absorbing 2 HDFE groups Residual df = 7 Wald chi2(1) = 0.53 Deviance = 13.36443052 Prob > chi2 = 0.4686 Log pseudolikelihood = -11.2959209 Pseudo R2 = 0.0607 ------------------------------------------------------------------------------ | Robust y | Coef. Std. Err. z P>|z| [95% Conf. Interval] -------------+---------------------------------------------------------------- x1 | -.4845469 .6685201 -0.72 0.469 -1.794822 .8257284 x2 | 0 (omitted) _cons | -.5708466 .4604099 -1.24 0.215 -1.473233 .3315402 ------------------------------------------------------------------------------ Absorbed degrees of freedom: -----------------------------------------------------+ Absorbed FE | Categories - Redundant = Num. Coefs | -------------+---------------------------------------| i | 3 0 3 | j | 3 1 2 | -----------------------------------------------------+ A difference with respect to Stata's 'ppmlhdfe' is that capybara requires an explicit cluster term in the formula to compute robust standard errors using a sandwich operation. ppmlhdfe$fe1$pair <- paste0(ppmlhdfe$fe1$i, ppmlhdfe$fe1$j) fepoisson( y ~ x1 + x2 | i + j | pair, data = ppmlhdfe$fe1 ) Other R packages may not detect separation in Poisson models with fixed effects. By disabling the separation check in Capybara, we can match 'alpaca' and 'fixest' results. Capybara without checking separation (incorrect $\\beta_2$): fepoisson( y ~ x1 + x2 | i + j, data = ppmlhdfe$fe1, control = list(check_separation = FALSE) ) Alpaca: alpaca::feglm( y ~ x1 + x2 | i + j, data = ppmlhdfe$fe1, family = poisson() ) `r poisson - log link, l= [4, 4] x1 x2 -0.4845 -17.3711 Fixest: fixest::feglm( y ~ x1 + x2 | i + j, data = ppmlhdfe$fe1, family = poisson() ) ``r GLM estimation, family = poisson, Dep. Var.: y Observations: 18 Fixed-effects: i: 4, j: 4 Standard-errors: IID Estimate Std. Error z value Pr(>|z|) x1 -0.484547 1.70957 -0.283432 0.77685 x2 -18.514805 6880.80328 -0.002691 0.99785 --- Signif. codes: 0 '' 0.001 '' 0.01 '' 0.05 '.' 0.1 ' ' 1 Log-Likelihood: -12.3 Adj. Pseudo R2: -0.353285 BIC: 50.6 Squared Cor.: 0.261426",
    "type": "vignette"
  }
]
